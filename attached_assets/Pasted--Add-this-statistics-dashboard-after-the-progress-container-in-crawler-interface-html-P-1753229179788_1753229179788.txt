<!-- Add this statistics dashboard after the progress container in crawler_interface.html -->
<!-- Place it right after the closing </div> of progress-container -->

<!-- Live Statistics Dashboard -->
<div class="row mt-3" id="stats-dashboard" style="display: none;">
    <div class="col-md-3">
        <div class="card text-center">
            <div class="card-body p-3">
                <h6 class="card-title mb-1">
                    <i data-feather="clock"></i> Elapsed Time
                </h6>
                <h4 class="mb-0" id="elapsed-time">00:00:00</h4>
            </div>
        </div>
    </div>
    <div class="col-md-3">
        <div class="card text-center">
            <div class="card-body p-3">
                <h6 class="card-title mb-1">
                    <i data-feather="trending-up"></i> Crawl Rate
                </h6>
                <h4 class="mb-0"><span id="crawl-rate">0</span> pages/min</h4>
            </div>
        </div>
    </div>
    <div class="col-md-3">
        <div class="card text-center">
            <div class="card-body p-3">
                <h6 class="card-title mb-1">
                    <i data-feather="database"></i> Data Size
                </h6>
                <h4 class="mb-0" id="data-size">0 KB</h4>
            </div>
        </div>
    </div>
    <div class="col-md-3">
        <div class="card text-center">
            <div class="card-body p-3">
                <h6 class="card-title mb-1">
                    <i data-feather="cpu"></i> Memory Usage
                </h6>
                <h4 class="mb-0" id="memory-usage">-- MB</h4>
            </div>
        </div>
    </div>
</div>

<!-- Add this JavaScript to handle the statistics updates -->
<script>
// Add these methods to your CrawlerInterface class

initializeStatistics() {
    this.stats = {
        startTime: null,
        pagesProcessed: 0,
        totalDataSize: 0,
        crawlRates: [],
        elapsedTimer: null
    };
}

startStatisticsTracking() {
    this.stats.startTime = Date.now();
    document.getElementById('stats-dashboard').style.display = 'flex';
    
    // Update elapsed time every second
    this.stats.elapsedTimer = setInterval(() => {
        this.updateElapsedTime();
    }, 1000);
    
    // Update crawl rate every 5 seconds
    setInterval(() => {
        this.calculateCrawlRate();
    }, 5000);
}

updateElapsedTime() {
    if (!this.stats.startTime) return;
    
    const elapsed = Date.now() - this.stats.startTime;
    const hours = Math.floor(elapsed / 3600000);
    const minutes = Math.floor((elapsed % 3600000) / 60000);
    const seconds = Math.floor((elapsed % 60000) / 1000);
    
    document.getElementById('elapsed-time').textContent = 
        `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

calculateCrawlRate() {
    if (!this.stats.startTime || this.stats.pagesProcessed === 0) return;
    
    const elapsedMinutes = (Date.now() - this.stats.startTime) / 60000;
    const rate = Math.round(this.stats.pagesProcessed / elapsedMinutes);
    
    document.getElementById('crawl-rate').textContent = rate;
    
    // Store historical rates for trending
    this.stats.crawlRates.push(rate);
    if (this.stats.crawlRates.length > 12) { // Keep last hour of data
        this.stats.crawlRates.shift();
    }
}

updateDataSize(sizeInBytes) {
    this.stats.totalDataSize += sizeInBytes;
    
    let displaySize;
    if (this.stats.totalDataSize < 1024) {
        displaySize = `${this.stats.totalDataSize} B`;
    } else if (this.stats.totalDataSize < 1024 * 1024) {
        displaySize = `${(this.stats.totalDataSize / 1024).toFixed(1)} KB`;
    } else {
        displaySize = `${(this.stats.totalDataSize / (1024 * 1024)).toFixed(1)} MB`;
    }
    
    document.getElementById('data-size').textContent = displaySize;
}

// Call this when starting crawl
startCrawling() {
    // ... existing code ...
    this.initializeStatistics();
    this.startStatisticsTracking();
    // ... rest of the method ...
}

// Update statistics when receiving progress updates
handleProgressUpdate(data) {
    // ... existing code ...
    this.stats.pagesProcessed = data.current;
    // Estimate data size (you can make this more accurate with actual data)
    this.updateDataSize(8192); // Example: 8KB per page average
}
</script>